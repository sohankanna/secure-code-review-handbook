# Session Lifecycle Security: Management & Protection

## 1. The Session Lifecycle Concept
A web session is a sequence of network transactions associated with the same user. Because HTTP is "stateless" (it forgets who you are after every request), applications use a **Session ID** (token) to bridge the gap.

As a Code Reviewer, you must analyze the session in four distinct phases:
1.  **Generation:** How is the ID created?
2.  **Transportation:** How is the ID sent between Client and Server?
3.  **Maintenance:** How is the ID handled while active (Rotation, Fixation)?
4.  **Termination:** How is the ID destroyed?

---

## 2. Phase 1: Generation & Properties
The Session ID is the "Key to the Kingdom." If an attacker guesses it, they bypass authentication entirely.

### A. Entropy and Length (PDF p. 66)
The guide dictates specific mathematical requirements for a secure Session ID:
*   **Length:** Must be at least **128 bits** (16 bytes).
*   **Entropy:** Must provide at least **64 bits** of entropy (randomness).
*   **Algorithm:** Must use a Cryptographically Secure Pseudo-Random Number Generator (CSPRNG), like `SHA-256`.

### B. Naming Conventions
Review the configuration files for the default Session ID name.
*   **Vulnerable:** Using default names like `PHPSESSID` (PHP), `JSESSIONID` (Java EE), or `ASPSESSIONID` (IIS). This leaks the underlying technology stack to the attacker.
*   **Secure:** Rename the cookie to something generic, like `id` or `token`.

### C. Code Example: Custom Session ID Generation (.NET)
Sometimes default generators aren't enough. Sample 8.7 (p. 69) shows how to implement a custom `SessionIDManager` in .NET using GUIDs (Globally Unique Identifiers) to ensure uniqueness and entropy.

**Secure .NET Implementation (Sample 8.7):**
```csharp
public class GuidSessionIDManager : SessionIDManager {
    // Override the creation to use a Cryptographic GUID
    public override string CreateSessionID(HttpContext context) {
        return Guid.NewGuid().ToString();
    }

    // Validate incoming IDs to ensure they match the GUID format
    // This prevents attackers from trying "funny" characters
    public override bool Validate(string id) {
        try {
            Guid testGuid = new Guid(id);
            if (id == testGuid.ToString()) return true;
        } catch (Exception e) {
            // Log error
        }
        return false;
    }
}
```

---

## 3. Phase 2: Transportation (Cookies vs. URL)
Where does the Session ID live? 

### ðŸš© Red Flag: URL Rewriting (PDF p. 68)
**Vulnerable:** `http://example.com/account?JSESSIONID=12345ABCDE`
*   **The Risk:** URLs are logged in browser history, proxy logs, and referrer headers. If a user shares a link, they accidentally share their session.
*   **Reviewer Action:** Check `php.ini` or `web.config` to ensure **Cookie-Only** mode is enforced.

**PHP Configuration Fix (Sample 8.9):**
```ini
; php.ini settings
session.use_trans_sid = 0    ; Disable transparent SID support (URL rewriting)
session.use_only_cookies = 1 ; Force cookies only
```

### The Cookie "Trinity" Flags (PDF p. 66)
When the session ID is stored in a cookie, three flags must be present in the code or configuration.

**1. Secure Flag:** Ensures the cookie is *never* sent over plain HTTP.
**2. HttpOnly Flag:** Prevents JavaScript (`document.cookie`) from reading the session ID (Mitigates XSS).
**3. Domain/Path:** Restricts the cookie to the specific application path.

**.NET Configuration (Sample 8.2):**
```xml
<!-- web.config -->
<authentication mode="Forms">
  <forms loginUrl="member_login.aspx"
         cookieless="UseCookies"  <!-- Forces Cookies, disables URL rewriting -->
         requireSSL="true"        <!-- Sets the 'Secure' flag -->
         path="/MyApplication" /> <!-- Restricts scope -->
</authentication>
```

**Java Configuration (Sample 8.3):**
```xml
<!-- web.xml -->
<session-config>
    <cookie-config>
        <secure>true</secure> <!-- Sets the 'Secure' flag -->
        <http-only>true</http-only> <!-- Sets the 'HttpOnly' flag -->
    </cookie-config>
</session-config>
```

**PHP Code Implementation (Sample 8.4):**
```php
// session_set_cookie_params(lifetime, path, domain, secure, httponly)
void session_set_cookie_params ( int $lifetime [, string $path [, string $domain [, bool $secure = true [, bool $httponly = true ]]]] )
```

---

## 4. Phase 3: Maintenance & Session Fixation
**Session Fixation** is an attack where the hacker creates a session ID, tricks the victim into using it (e.g., via a link), and then waits for the victim to log in. If the ID doesn't change upon login, the hacker now possesses the authenticated session.

### The Fix: Session Rotation
The guide (p. 68) is explicit: **"All the session-ids should be generated by the application... If the application sees a new session-id that is not present in the pool, it should be rejected."**

Most importantly: **Renew the Session ID after login.**

**Java Logic for Anti-Fixation (Sample 8.8):**
```java
// 1. Invalidate the old session (destroying the 'guest' ID)
request.getSession(false).invalidate();

// 2. Create a brand new session (generating a new 'authenticated' ID)
HttpSession newSession = request.getSession(true);
```

**.NET Logic:**
In ASP.NET, preventing fixation is harder because the framework manages the ID. The trick is to `Abandon` the session and set a new cookie explicitly.

---

## 5. Phase 4: Termination & Timeouts
Sessions must eventually die. If they persist forever, an attacker can use a stolen cookie weeks later.

### A. Idle Timeouts
The application should disconnect the user after a period of inactivity.

**.NET Timeout Config (Sample 8.5):**
```xml
<system.web>
 <sessionState 
    mode="InProc"
    cookieless="false" 
    timeout="15" /> <!-- Timeout in Minutes -->
</system.web>
```

**Java Timeout Config (Sample 8.6):**
```xml
<session-config>
    <session-timeout>1</session-timeout> <!-- Timeout in Minutes -->
</session-config>
```

### B. Proper Logout Logic (PDF p. 67)
Clicking "Logout" is not enough. The server must destroy the data.

**.NET Secure Logout:**
```csharp
// Session.Clear() only removes items, it does NOT destroy the session.
// You MUST use Abandon().
Session.Abandon(); 
```

**Java Secure Logout:**
```java
session.invalidate();
```

---

## 6. Session Elevation (Privilege Escalation)
The guide (p. 68) introduces the concept of **Session Elevation**.
*   **Scenario:** A user logs in as a "Standard User." Later, they enter an admin password to access a sensitive area.
*   **The Flaw:** If the application just adds an "Admin Flag" to the *existing* session, it is weak.
*   **The Fix:** "Whenever a session is elevated (login, logout, certain authorization), it should be rolled." (New Session ID generated).

---

## 7. Secure Code Reviewerâ€™s Checklist (Session Management)

### Configuration Files (`web.config`, `web.xml`, `php.ini`)
- [ ] **Cookie Mode:** Is URL rewriting disabled (`cookieless="UseCookies"` / `session.use_only_cookies`)?
- [ ] **Secure Flag:** Is `requireSSL` or `<secure>true</secure>` enabled?
- [ ] **HttpOnly:** Is javascript access to cookies disabled?
- [ ] **Timeout:** Is the timeout set to a reasonable business limit (e.g., 15 mins for banking, 60 mins for forums)?

### Source Code Logic
- [ ] **Login Rotation:** Does the code explicitly destroy the old session and create a new one immediately after password verification? (Prevents Fixation).
- [ ] **Entropy:** If custom session IDs are generated, is `SecureRandom` or `RNGCryptoServiceProvider` used? (Never use `Math.random()`).
- [ ] **Logout:** Does the Logout button call `Abandon()` or `invalidate()` on the server?
- [ ] **Error Handling:** If a session ID is invalid/expired, does the application redirect gracefully to the login page without crashing or revealing stack traces?

---

*Reference: OWASP Code Review Guide 2.0 (Pages 65-70)*
