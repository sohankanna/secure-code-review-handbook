
# Mass Assignment & Over-Posting: The "Hidden Field" Attack

## 1. Executive Summary
Modern web frameworks (like ASP.NET MVC, Spring MVC, and Ruby on Rails) try to make the developer's life easier by automatically converting HTTP Request parameters into Code Objects. This feature is called **Model Binding** or **Mass Assignment**.

**The Vulnerability:**
If the framework automatically binds *every* parameter sent by the user to the internal code object, an attacker can modify internal fields (like `IsAdmin`, `Balance`, or `IsApproved`) simply by adding them to the HTTP request, even if those fields were never displayed in the HTML form.

### The Pizza Analogy
Imagine ordering a pizza online. The form asks for:
*   **Toppings:** Pepperoni
*   **Size:** Large

The internal "Pizza Object" in the code has a property called `Price`.
An attacker intercepts the order and adds: `&Price=0.01`.
If Mass Assignment is enabled without protections, the system sees the `Price` parameter, finds the `Price` property on the Pizza Object, and updates it to **$0.01** automatically.

---

## 2. The Mechanics: How Model Binding Works
To understand the flaw, you must understand the feature. In .NET MVC (the focus of the guide's examples), developers write "Action Methods" that take objects as parameters.

### The Convenience
Instead of writing this (The Hard Way):
```csharp
public ActionResult UpdateProfile() {
    User user = new User();
    user.Name = Request.Form["Name"];
    user.Email = Request.Form["Email"];
    // ... repeat for 20 fields ...
    db.Save(user);
}
```

Developers write this (The Easy Way - **Auto Binding**):
```csharp
public ActionResult UpdateProfile(User user) {
    // The Framework automatically looks at the Request.
    // It finds "Name" and sets user.Name.
    // It finds "Email" and sets user.Email.
    db.Save(user);
}
```

**The Danger:** The framework will map **ANYTHING** it finds in the request to **ANY** matching public property in the `User` class.

---

## 3. The Vulnerable Code Analysis (Sample 10.2 & 10.3)
The OWASP Guide provides a specific C# .NET example on **Page 80** to illustrate this.

### A. The Data Model (The Internal Object)
This is the class definition in the code. Note the properties.

```csharp
// Sample 10.2: The User Class
public class User
{
    public int ID { get; set; }          // Exposed in View
    public string Name { get; set; }     // Exposed in View
    
    // THE SECRET TARGET
    public bool isAdmin { get; set; }    // Hidden from View
}
```

### B. The View (The HTML Form)
This is what the regular user sees. Note that `isAdmin` is NOT in the form.

```html
<!-- Sample 10.3: The View -->
ID: <%= Html.TextBox("ID") %> <br>
Name: <%= Html.TextBox("Name") %> <br>
<input type="submit" value="Save" />
```

### C. The Vulnerable Controller
The controller receives the data.

```csharp
[HttpPost]
public ActionResult Update(User user) {
    // VULNERABILITY HAPPENS HERE
    // The 'user' object is already populated with whatever was sent.
    // If the attacker sent &isAdmin=true, user.isAdmin is now true.
    
    database.Update(user);
    return View("Success");
}
```

---

## 4. The Attack Vector
An attacker does not need to hack the database. They simply need to guess the name of the internal fields.

1.  **Reconnaissance:** The attacker looks at the HTML source or previous requests. They see fields like `FirstName`, `LastName`, `user_id`.
2.  **Hypothesis:** "If there is a `user_id`, maybe there is a `role`, `admin`, `IsAdmin`, or `Privilege` field."
3.  **Execution:** The attacker submits the "Update Profile" form but intercepts the request (using a proxy like ZAP or Burp Suite).
4.  **Modification:** They append `&isAdmin=true` to the body of the POST request.
5.  **Result:** The .NET Framework sees the parameter `isAdmin`, finds the property `public bool isAdmin` in the class, and sets it to `true`. The database is updated, and the user becomes an admin.

---

## 5. Remediation Strategies (PDF p. 81)
The guide outlines three specific ways to fix this in .NET MVC code. As a reviewer, you are looking for one of these patterns.

### Strategy 1: The "View Model" (Best Practice)
Do not use your Database Entity (the `User` class) in the Controller. Create a specific, smaller class that **only** contains the fields the user is allowed to edit.

**Secure Code:**
```csharp
// 1. Create a View Model (DTO)
public class UserProfileViewModel {
    public string Name { get; set; }
    // Note: isAdmin is NOT in this class.
}

// 2. Use the View Model in the Controller
public ActionResult Update(UserProfileViewModel data) {
    // Even if attacker sends &isAdmin=true, the 'data' object 
    // has nowhere to put it. It is ignored.
    
    User actualUser = db.GetUser();
    actualUser.Name = data.Name; // Manually copy allowed fields
    db.Save(actualUser);
}
```

### Strategy 2: The "Bind" Attribute (Whitelisting)
You can keep using the main User class, but tell the framework explicitly which fields to accept.

**Secure Code:**
```csharp
// Only allow "Name" and "ID". Everything else is ignored.
public ActionResult Update([Bind(Include="Name,ID")] User user) {
    db.Save(user);
}
```
*   **Reviewer Check:** Look for `[Bind(Include=...)]`. If you see `[Bind(Exclude=...)]`, flag it as a warning. **Exclude (Blacklisting)** is dangerous because you might forget to exclude a new sensitive field added later.

### Strategy 3: UpdateModel with Inclusions
If using the `UpdateModel()` function inside the controller (instead of parameter binding), you can pass a whitelist of allowed properties.

**Secure Code:**
```csharp
public ActionResult Update() {
    User user = db.GetUser();
    // Only update "Name" and "ID" from the request data
    TryUpdateModel(user, "", new string[] { "Name", "ID" }); 
    db.Save(user);
}
```

---

## 6. Secure Code Reviewerâ€™s "Grep" Guide
How do you find Mass Assignment in a large codebase?

### 1. Identify the Models
Look for classes that map to database tables. Check for sensitive fields:
*   `IsAdmin`, `Role`, `Balance`, `Approved`, `Price`, `Discount`.

### 2. Identify the Controllers
Look for Action Methods that take these Models as **Parameters**.
*   **Vulnerable:** `public ActionResult Edit(User user)`
*   **Likely Secure:** `public ActionResult Edit(UserViewModel data)`

### 3. Check for Protections
If the Model is passed directly, look immediately for the `[Bind]` attribute.
*   **Missing Bind:** "High Severity: Mass Assignment Vulnerability."
*   **Bind with Exclude:** "Medium Severity: Use Include (Whitelist) instead of Exclude (Blacklist)."

### 4. Check for `TryUpdateModel`
If the code manually calls `UpdateModel` or `TryUpdateModel`, check the arguments.
*   **Vulnerable:** `UpdateModel(user)` (Updates *everything*).
*   **Secure:** `UpdateModel(user, "prefix", new[] {"AllowedField"})`.

---

## 7. Summary for the Exam
*   **Mass Assignment** allows attackers to modify object properties they shouldn't access.
*   It happens because frameworks auto-magically map **HTTP Parameters** -> **Code Properties**.
*   It is an **IDOR** of the object's properties.
*   **Defense:** Never use Database Entities directly in Controllers. Use **View Models (DTOs)** or strict **Whitelisting ([Bind])**.

---
*Reference: OWASP Code Review Guide 2.0 (Pages 80-81)*
